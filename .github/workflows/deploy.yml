# GCP Observability Demo - Full Deployment Pipeline
# This workflow provisions infrastructure and deploys all applications

name: Deploy Observability Demo

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - destroy
          - stop
          - start
      environment:
        description: 'Environment name'
        required: true
        default: 'demo'
        type: string
      region:
        description: 'GCP Region'
        required: true
        default: 'us-central1'
        type: choice
        options:
          - us-central1
          - us-east1
          - us-west1
          - europe-west1
          - asia-southeast1
      zone:
        description: 'GCP Zone (for zonal clusters)'
        required: true
        default: 'us-central1-a'
        type: choice
        options:
          - us-central1-a
          - us-central1-b
          - us-central1-c
          - us-east1-b
          - us-west1-a
          - europe-west1-b
          - asia-southeast1-a
      auto_approve:
        description: 'Auto-approve Terraform changes'
        required: false
        default: false
        type: boolean

env:
  TF_VERSION: '1.6.0'
  KUBECTL_VERSION: 'v1.28.0'
  HELM_VERSION: 'v3.13.0'

jobs:
  # ============================================
  # DEPLOY: Full infrastructure + applications
  # ============================================
  deploy:
    if: ${{ github.event.inputs.action == 'deploy' }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Install GKE Auth Plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin --quiet
          echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}

      # ---- Terraform Infrastructure ----
      - name: Terraform Init
        working-directory: terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.GCP_PROJECT_ID }}-tfstate" \
            -backend-config="prefix=observ-demo/${{ github.event.inputs.environment }}"

      - name: Import Existing Resources (if needed)
        working-directory: terraform
        run: |
          set -e  # Exit on error

          CLUSTER_NAME="${{ secrets.GCP_PROJECT_ID }}-gke"
          NODE_POOL_NAME="${CLUSTER_NAME}-node-pool"
          PROJECT_ID="${{ secrets.GCP_PROJECT_ID }}"
          ZONE="${{ github.event.inputs.zone }}"

          echo "=== Checking for existing GCP resources to import ==="
          echo "Cluster: $CLUSTER_NAME"
          echo "Node Pool: $NODE_POOL_NAME"
          echo "Zone: $ZONE"
          echo ""

          # Check if cluster exists in GCP
          echo "Checking if cluster exists in GCP..."
          if gcloud container clusters describe $CLUSTER_NAME --zone=$ZONE --project=$PROJECT_ID 2>/dev/null; then
            echo "✓ Cluster exists in GCP"

            # Check if cluster is in Terraform state
            echo "Checking Terraform state for cluster..."
            if terraform state show module.gke_cluster.google_container_cluster.primary 2>/dev/null; then
              echo "✓ Cluster already in Terraform state"
            else
              echo "⚠ Cluster NOT in state. Importing..."
              terraform import \
                -var="project_id=$PROJECT_ID" \
                -var="region=${{ github.event.inputs.region }}" \
                -var="zone=$ZONE" \
                -var="environment=${{ github.event.inputs.environment }}" \
                -var="billing_account=${{ secrets.GCP_BILLING_ACCOUNT }}" \
                module.gke_cluster.google_container_cluster.primary \
                "projects/$PROJECT_ID/locations/$ZONE/clusters/$CLUSTER_NAME"
              echo "✓ Cluster imported successfully"
            fi

            # Check if node pool exists in GCP
            echo ""
            echo "Checking if node pool exists in GCP..."
            if gcloud container node-pools describe $NODE_POOL_NAME --cluster=$CLUSTER_NAME --zone=$ZONE --project=$PROJECT_ID 2>/dev/null; then
              echo "✓ Node pool exists in GCP"

              # Check if node pool is in Terraform state
              echo "Checking Terraform state for node pool..."
              if terraform state show module.gke_cluster.google_container_node_pool.primary_nodes 2>/dev/null; then
                echo "✓ Node pool already in Terraform state"
              else
                echo "⚠ Node pool NOT in state. Importing..."
                terraform import \
                  -var="project_id=$PROJECT_ID" \
                  -var="region=${{ github.event.inputs.region }}" \
                  -var="zone=$ZONE" \
                  -var="environment=${{ github.event.inputs.environment }}" \
                  -var="billing_account=${{ secrets.GCP_BILLING_ACCOUNT }}" \
                  module.gke_cluster.google_container_node_pool.primary_nodes \
                  "projects/$PROJECT_ID/locations/$ZONE/clusters/$CLUSTER_NAME/nodePools/$NODE_POOL_NAME"
                echo "✓ Node pool imported successfully"
              fi
            else
              echo "Node pool does not exist in GCP yet (will be created)"
            fi
          else
            echo "Cluster does not exist in GCP yet (will be created)"
          fi

          echo ""
          echo "=== Import check complete ==="

      - name: Terraform Plan
        working-directory: terraform
        run: |
          terraform plan \
            -var="project_id=${{ secrets.GCP_PROJECT_ID }}" \
            -var="region=${{ github.event.inputs.region }}" \
            -var="zone=${{ github.event.inputs.zone }}" \
            -var="environment=${{ github.event.inputs.environment }}" \
            -var="billing_account=${{ secrets.GCP_BILLING_ACCOUNT }}" \
            -out=tfplan

      - name: Terraform Apply
        working-directory: terraform
        run: |
          if [ "${{ github.event.inputs.auto_approve }}" == "true" ]; then
            terraform apply -auto-approve tfplan
          else
            terraform apply tfplan
          fi

      - name: Get Cluster Name from Terraform
        id: tf-outputs
        working-directory: terraform
        run: |
          CLUSTER_NAME=$(terraform output -raw cluster_name)
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "Cluster name: $CLUSTER_NAME"

      # ---- Configure kubectl ----
      - name: Get GKE Credentials
        run: |
          gcloud container clusters get-credentials ${{ steps.tf-outputs.outputs.cluster_name }} \
            --zone ${{ github.event.inputs.zone }} \
            --project ${{ secrets.GCP_PROJECT_ID }}

      - name: Verify Cluster Connection
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Wait for Cluster Nodes to be Ready
        run: |
          echo "Waiting for all nodes to be Ready..."
          # Wait up to 10 minutes for nodes to be ready
          for i in {1..20}; do
            READY_NODES=$(kubectl get nodes --no-headers 2>/dev/null | grep -c " Ready" || echo "0")
            TOTAL_NODES=$(kubectl get nodes --no-headers 2>/dev/null | wc -l || echo "0")
            echo "Attempt $i/20: $READY_NODES/$TOTAL_NODES nodes ready"
            if [ "$READY_NODES" -gt 0 ] && [ "$READY_NODES" -eq "$TOTAL_NODES" ]; then
              echo "All nodes are ready!"
              kubectl get nodes
              break
            fi
            if [ $i -eq 20 ]; then
              echo "Warning: Not all nodes ready after 10 minutes"
              kubectl get nodes
              kubectl describe nodes || true
            fi
            sleep 30
          done

      - name: Wait for System Pods
        run: |
          echo "Waiting for kube-system pods to be ready..."
          kubectl wait --for=condition=ready pod \
            --all \
            --namespace=kube-system \
            --timeout=300s || true
          kubectl get pods -n kube-system

      # ---- Deploy Observability Stack ----
      - name: Create Observability Namespace
        run: |
          kubectl create namespace observability --dry-run=client -o yaml | kubectl apply -f -
          kubectl label namespace observability name=observability --overwrite

      - name: Deploy Jaeger
        working-directory: kubernetes/observability
        run: |
          kubectl apply -f jaeger-all-in-one.yaml
          echo "Waiting for Jaeger to be ready..."
          kubectl wait --for=condition=ready pod \
            --selector=app=jaeger \
            --namespace=observability \
            --timeout=300s

      - name: Add Helm Repositories
        run: |
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo add open-telemetry https://open-telemetry.github.io/opentelemetry-helm-charts
          helm repo update

      - name: Deploy Prometheus Stack
        working-directory: kubernetes/observability
        run: |
          echo "Deploying Prometheus stack (this may take several minutes)..."
          helm upgrade --install prometheus \
            prometheus-community/kube-prometheus-stack \
            --namespace observability \
            --values prometheus-values.yaml \
            --wait \
            --timeout 15m \
            --debug 2>&1 | tail -100 || {
              echo "Helm install failed. Checking pod status..."
              kubectl get pods -n observability
              kubectl describe pods -n observability -l app.kubernetes.io/name=kube-prometheus-stack-operator || true
              exit 1
            }

      - name: Deploy Grafana
        working-directory: kubernetes/observability
        run: |
          kubectl apply -f grafana.yaml
          echo "Waiting for Grafana to be ready..."
          kubectl wait --for=condition=ready pod \
            --selector=app=grafana \
            --namespace=observability \
            --timeout=300s

      - name: Create Dashboard ConfigMaps
        working-directory: kubernetes/observability
        run: |
          kubectl create configmap grafana-dashboards-sre \
            --from-file=dashboards/ \
            --namespace=observability \
            --dry-run=client -o yaml | kubectl apply -f -

      # ---- Deploy OpenTelemetry Collector ----
      - name: Create OpenTelemetry Namespace
        run: |
          kubectl create namespace opentelemetry --dry-run=client -o yaml | kubectl apply -f -
          kubectl label namespace opentelemetry name=opentelemetry --overwrite

      - name: Deploy OpenTelemetry Collector
        working-directory: kubernetes/opentelemetry
        run: |
          helm upgrade --install otel-collector \
            open-telemetry/opentelemetry-collector \
            --namespace opentelemetry \
            --values values-collector.yaml \
            --wait \
            --timeout 10m

      # ---- Deploy Microservices Demo ----
      - name: Create Microservices Namespace
        run: |
          kubectl create namespace microservices-demo --dry-run=client -o yaml | kubectl apply -f -
          kubectl label namespace microservices-demo name=microservices-demo --overwrite

      - name: Deploy Microservices Demo
        run: |
          # Clone the microservices-demo repo to get the Helm chart
          git clone --depth 1 https://github.com/GoogleCloudPlatform/microservices-demo.git /tmp/microservices-demo

          # Install without --wait to avoid API rate limiting on GKE Autopilot
          # Use simplified values that disable loadgenerator and let Autopilot set resources
          helm upgrade --install microservices-demo \
            /tmp/microservices-demo/helm-chart \
            --namespace microservices-demo \
            --values kubernetes/microservices-demo/values-gcp.yaml \
            --timeout 5m

      - name: Wait for Microservices Demo Pods
        run: |
          echo "Waiting for microservices-demo pods to be ready..."
          # Wait up to 10 minutes for pods to be ready, checking every 30 seconds
          for i in {1..20}; do
            READY=$(kubectl get pods -n microservices-demo --no-headers 2>/dev/null | grep -c "Running" || echo "0")
            TOTAL=$(kubectl get pods -n microservices-demo --no-headers 2>/dev/null | wc -l || echo "0")
            echo "Attempt $i/20: $READY/$TOTAL pods running"
            if [ "$READY" -ge 10 ] && [ "$READY" -eq "$TOTAL" ]; then
              echo "All pods are running!"
              break
            fi
            if [ $i -eq 20 ]; then
              echo "Warning: Not all pods are ready after 10 minutes, but continuing..."
              kubectl get pods -n microservices-demo
            fi
            sleep 30
          done

      # ---- Deployment Summary ----
      - name: Deployment Summary
        run: |
          echo "============================================"
          echo "DEPLOYMENT COMPLETE"
          echo "============================================"
          echo ""
          echo "Cluster: ${{ steps.tf-outputs.outputs.cluster_name }}"
          echo "Zone: ${{ github.event.inputs.zone }}"
          echo "Project: ${{ secrets.GCP_PROJECT_ID }}"
          echo ""
          echo "Pods Status:"
          kubectl get pods -A | grep -E "observability|opentelemetry|microservices"
          echo ""
          echo "Services:"
          kubectl get svc -n observability
          echo ""
          echo "============================================"
          echo "ACCESS INSTRUCTIONS"
          echo "============================================"
          echo ""
          echo "Run these commands locally to access the stack:"
          echo ""
          echo "# Configure kubectl:"
          echo "gcloud container clusters get-credentials ${{ steps.tf-outputs.outputs.cluster_name }} \\"
          echo "  --zone ${{ github.event.inputs.zone }} \\"
          echo "  --project ${{ secrets.GCP_PROJECT_ID }}"
          echo ""
          echo "# Jaeger (Traces):"
          echo "kubectl port-forward -n observability svc/jaeger-query 16686:16686"
          echo "# Access: http://localhost:16686"
          echo ""
          echo "# Prometheus (Metrics & Alerts):"
          echo "kubectl port-forward -n observability svc/prometheus-kube-prometheus-prometheus 9090:9090"
          echo "# Access: http://localhost:9090"
          echo "# Note: Alerts visible in Prometheus UI > Alerts"
          echo ""
          echo "# Grafana (Dashboards):"
          echo "kubectl port-forward -n observability svc/grafana 3000:3000"
          echo "# Access: http://localhost:3000 (admin/admin123)"
          echo ""
          echo "# Microservices Demo Frontend:"
          echo "kubectl port-forward -n microservices-demo svc/frontend 8080:80"
          echo "# Access: http://localhost:8080"
          echo ""

  # ============================================
  # STOP: Scale all deployments to zero
  # ============================================
  stop:
    if: ${{ github.event.inputs.action == 'stop' }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}

    steps:
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Install GKE Auth Plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin --quiet
          echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Get GKE Credentials
        run: |
          GKE_CLUSTER_NAME="${{ secrets.GCP_PROJECT_ID }}-gke"
          gcloud container clusters get-credentials $GKE_CLUSTER_NAME \
            --zone ${{ github.event.inputs.zone }} \
            --project ${{ secrets.GCP_PROJECT_ID }}

      - name: Scale Down All Deployments
        run: |
          echo "Scaling down observability namespace..."
          kubectl scale deployment -n observability --replicas=0 --all || true
          kubectl scale statefulset -n observability --replicas=0 --all || true

          echo "Scaling down opentelemetry namespace..."
          kubectl scale deployment -n opentelemetry --replicas=0 --all || true

          echo "Scaling down microservices-demo namespace..."
          kubectl scale deployment -n microservices-demo --replicas=0 --all || true

          echo ""
          echo "All deployments scaled to zero. Run 'start' action to resume."
          echo "Note: GKE Autopilot will scale down nodes automatically."

      - name: Show Status
        run: |
          echo "Current pod status (should be empty or terminating):"
          kubectl get pods -A | grep -E "observability|opentelemetry|microservices" || echo "No pods running"

  # ============================================
  # START: Scale deployments back up
  # ============================================
  start:
    if: ${{ github.event.inputs.action == 'start' }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}

    steps:
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Install GKE Auth Plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin --quiet
          echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Get GKE Credentials
        run: |
          GKE_CLUSTER_NAME="${{ secrets.GCP_PROJECT_ID }}-gke"
          gcloud container clusters get-credentials $GKE_CLUSTER_NAME \
            --zone ${{ github.event.inputs.zone }} \
            --project ${{ secrets.GCP_PROJECT_ID }}

      - name: Scale Up All Deployments
        run: |
          echo "Scaling up observability namespace..."
          kubectl scale deployment -n observability --replicas=1 --all || true
          kubectl scale statefulset -n observability --replicas=1 --all || true

          echo "Scaling up opentelemetry namespace..."
          kubectl scale deployment -n opentelemetry --replicas=2 --all || true

          echo "Scaling up microservices-demo namespace..."
          kubectl scale deployment -n microservices-demo --replicas=1 --all || true

          echo ""
          echo "All deployments scaled up. Waiting for pods to be ready..."

      - name: Wait for Pods
        run: |
          echo "Waiting for pods to be ready (this may take a few minutes)..."
          kubectl wait --for=condition=ready pod --all -n observability --timeout=300s || true
          kubectl wait --for=condition=ready pod --all -n opentelemetry --timeout=300s || true
          kubectl wait --for=condition=ready pod --all -n microservices-demo --timeout=300s || true

      - name: Show Status
        run: |
          echo "Current pod status:"
          kubectl get pods -A | grep -E "observability|opentelemetry|microservices"

  # ============================================
  # DESTROY: Remove all resources
  # ============================================
  destroy:
    if: ${{ github.event.inputs.action == 'destroy' }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Install GKE Auth Plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin --quiet
          echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Get GKE Credentials
        continue-on-error: true
        run: |
          GKE_CLUSTER_NAME="${{ secrets.GCP_PROJECT_ID }}-gke"
          gcloud container clusters get-credentials $GKE_CLUSTER_NAME \
            --zone ${{ github.event.inputs.zone }} \
            --project ${{ secrets.GCP_PROJECT_ID }}

      - name: Delete Kubernetes Resources
        continue-on-error: true
        run: |
          echo "Deleting Kubernetes namespaces..."
          kubectl delete namespace microservices-demo --ignore-not-found=true --timeout=120s || true
          kubectl delete namespace opentelemetry --ignore-not-found=true --timeout=120s || true
          kubectl delete namespace observability --ignore-not-found=true --timeout=120s || true
          echo "Kubernetes resources deleted."

      - name: Delete Network Endpoint Groups (NEGs)
        continue-on-error: true
        run: |
          echo "Cleaning up Network Endpoint Groups created by GKE..."
          VPC_NAME="${{ secrets.GCP_PROJECT_ID }}-vpc"

          # List all NEGs in the zone
          echo "Finding NEGs in zone ${{ github.event.inputs.zone }}..."
          NEGS=$(gcloud compute network-endpoint-groups list \
            --filter="zone:${{ github.event.inputs.zone }}" \
            --format="value(name)" \
            --project=${{ secrets.GCP_PROJECT_ID }} 2>/dev/null || echo "")

          if [ -n "$NEGS" ]; then
            echo "Found NEGs to delete:"
            echo "$NEGS"
            for NEG in $NEGS; do
              echo "Deleting NEG: $NEG"
              gcloud compute network-endpoint-groups delete "$NEG" \
                --zone=${{ github.event.inputs.zone }} \
                --project=${{ secrets.GCP_PROJECT_ID }} \
                --quiet || true
            done
            echo "NEG cleanup complete."
          else
            echo "No NEGs found in zone ${{ github.event.inputs.zone }}"
          fi

      - name: Delete Firewall Rules
        continue-on-error: true
        run: |
          echo "Cleaning up firewall rules..."
          VPC_NAME="${{ secrets.GCP_PROJECT_ID }}-vpc"

          # Find and delete firewall rules associated with the VPC
          FIREWALL_RULES=$(gcloud compute firewall-rules list \
            --filter="network:$VPC_NAME" \
            --format="value(name)" \
            --project=${{ secrets.GCP_PROJECT_ID }} 2>/dev/null || echo "")

          if [ -n "$FIREWALL_RULES" ]; then
            echo "Found firewall rules to delete:"
            echo "$FIREWALL_RULES"
            for RULE in $FIREWALL_RULES; do
              echo "Deleting firewall rule: $RULE"
              gcloud compute firewall-rules delete "$RULE" \
                --project=${{ secrets.GCP_PROJECT_ID }} \
                --quiet || true
            done
            echo "Firewall cleanup complete."
          else
            echo "No firewall rules found for VPC $VPC_NAME"
          fi

      - name: Terraform Init
        working-directory: terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.GCP_PROJECT_ID }}-tfstate" \
            -backend-config="prefix=observ-demo/${{ github.event.inputs.environment }}"

      - name: Terraform Destroy
        working-directory: terraform
        run: |
          terraform destroy \
            -var="project_id=${{ secrets.GCP_PROJECT_ID }}" \
            -var="region=${{ github.event.inputs.region }}" \
            -var="zone=${{ github.event.inputs.zone }}" \
            -var="environment=${{ github.event.inputs.environment }}" \
            -var="billing_account=${{ secrets.GCP_BILLING_ACCOUNT }}" \
            -auto-approve

      - name: Cleanup Summary
        run: |
          echo "============================================"
          echo "DESTROY COMPLETE"
          echo "============================================"
          echo ""
          echo "All resources have been destroyed."
          echo "Terraform state has been updated."
          echo ""
          echo "To redeploy, run the 'deploy' action."
